{"version":3,"sources":["turbopack:///[project]/src/lib/supabase.ts","turbopack:///[project]/src/lib/supabase-buckets.ts","turbopack:///[project]/src/app/api/upload/route.ts","turbopack:///[project]/node_modules/next/dist/esm/build/templates/app-route.js"],"sourcesContent":["import { createClient } from '@supabase/supabase-js'\n\n// Supabase configuration\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase environment variables. Please check your .env.local file.')\n}\n\n// Create a single supabase client for interacting with your database\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey, {\n  auth: {\n    persistSession: true,\n    autoRefreshToken: true,\n  },\n})\n\n// Storage bucket names from environment\nexport const STORAGE_BUCKETS = {\n  PROJECT_PHOTOS: process.env.SUPABASE_PROJECT_PHOTOS_BUCKET || 'project-photos',\n  WORK_PHOTOS: process.env.SUPABASE_WORK_PHOTOS_BUCKET || 'work-photos',\n  PROJECT_DOCUMENTS: process.env.SUPABASE_PROJECT_DOCUMENTS_BUCKET || 'project-documents',\n  HOUSE_DOCUMENTS: process.env.SUPABASE_HOUSE_DOCUMENTS_BUCKET || 'house-documents',\n  USER_AVATARS: process.env.SUPABASE_USER_AVATARS_BUCKET || 'user-avatars',\n  REPORTS: process.env.SUPABASE_REPORTS_BUCKET || 'reports',\n} as const\n\n// File upload configuration\nexport const FILE_UPLOAD_CONFIG = {\n  // Maximum file size: 10MB\n  MAX_FILE_SIZE: 10 * 1024 * 1024,\n\n  // Maximum files per batch upload\n  MAX_FILES_PER_BATCH: 5,\n\n  // Allowed file types\n  ALLOWED_FILE_TYPES: {\n    IMAGES: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],\n    DOCUMENTS: ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],\n    SPREADSHEETS: ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],\n    PLANS: ['application/pdf', 'application/dwg', 'application/dxf'],\n  },\n\n  // Get all allowed MIME types\n  getAllowedTypes: () => [\n    ...FILE_UPLOAD_CONFIG.ALLOWED_FILE_TYPES.IMAGES,\n    ...FILE_UPLOAD_CONFIG.ALLOWED_FILE_TYPES.DOCUMENTS,\n    ...FILE_UPLOAD_CONFIG.ALLOWED_FILE_TYPES.SPREADSHEETS,\n    ...FILE_UPLOAD_CONFIG.ALLOWED_FILE_TYPES.PLANS,\n  ],\n} as const\n\n// File validation utilities\nexport const validateFile = (file: File) => {\n  const errors: string[] = []\n\n  // Check file size\n  if (file.size > FILE_UPLOAD_CONFIG.MAX_FILE_SIZE) {\n    errors.push(`File size must be less than ${FILE_UPLOAD_CONFIG.MAX_FILE_SIZE / (1024 * 1024)}MB`)\n  }\n\n  // Check file type\n  const allowedTypes = FILE_UPLOAD_CONFIG.getAllowedTypes()\n  if (!allowedTypes.includes(file.type)) {\n    errors.push(`File type ${file.type} is not allowed`)\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  }\n}\n\n// Generate secure file name\nexport const generateSecureFileName = (originalFileName: string, userId?: string) => {\n  const timestamp = Date.now()\n  const randomString = Math.random().toString(36).substring(2, 15)\n  const fileExtension = originalFileName.split('.').pop()\n  const baseName = originalFileName.split('.')[0].toLowerCase().replace(/[^a-z0-9]/g, '-')\n\n  const prefix = userId ? `${userId}_` : ''\n  return `${prefix}${baseName}_${timestamp}_${randomString}.${fileExtension}`\n}\n\n// Get file category based on bucket\nexport const getFileCategoryFromBucket = (bucketName: string) => {\n  const bucketMap = {\n    [STORAGE_BUCKETS.PROJECT_PHOTOS]: 'project-photo',\n    [STORAGE_BUCKETS.WORK_PHOTOS]: 'work-photo',\n    [STORAGE_BUCKETS.PROJECT_DOCUMENTS]: 'project-document',\n    [STORAGE_BUCKETS.HOUSE_DOCUMENTS]: 'house-document',\n    [STORAGE_BUCKETS.USER_AVATARS]: 'user-avatar',\n    [STORAGE_BUCKETS.REPORTS]: 'report',\n  } as const\n\n  return bucketMap[bucketName as keyof typeof bucketMap] || 'unknown'\n}","import { supabase } from './supabase'\nimport type { StorageBucket } from '@/types/upload'\n\n/**\n * Configuration for each Supabase Storage bucket\n */\nexport const BUCKET_CONFIGS = {\n  'project-photos': {\n    name: 'project-photos',\n    public: false,\n    allowedMimeTypes: ['image/jpeg', 'image/png', 'image/webp', 'image/gif'],\n    fileSizeLimit: 10 * 1024 * 1024, // 10MB\n    description: 'Project construction photos and progress images',\n    folderStructure: 'projects/{project_id}/{category}/{date}/',\n    examplePath: 'projects/abc123/before/2024-01-15/',\n  },\n  'work-photos': {\n    name: 'work-photos',\n    public: false,\n    allowedMimeTypes: ['image/jpeg', 'image/png', 'image/webp', 'image/gif'],\n    fileSizeLimit: 10 * 1024 * 1024, // 10MB\n    description: 'Work entry photos showing completed work',\n    folderStructure: 'work-entries/{work_entry_id}/{timestamp}/',\n    examplePath: 'work-entries/we456/2024-01-15T10:30:00Z/',\n  },\n  'project-documents': {\n    name: 'project-documents',\n    public: false,\n    allowedMimeTypes: [\n      'application/pdf',\n      'application/msword',\n      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n      'application/vnd.ms-excel',\n      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n      'application/dwg',\n      'application/dxf',\n    ],\n    fileSizeLimit: 50 * 1024 * 1024, // 50MB for documents\n    description: 'Project documents, plans, and technical files',\n    folderStructure: 'projects/{project_id}/{document_type}/',\n    examplePath: 'projects/abc123/plans/',\n  },\n  'house-documents': {\n    name: 'house-documents',\n    public: false,\n    allowedMimeTypes: [\n      'application/pdf',\n      'application/msword',\n      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n      'image/jpeg',\n      'image/png',\n    ],\n    fileSizeLimit: 10 * 1024 * 1024, // 10MB\n    description: 'House-specific documents and certificates',\n    folderStructure: 'houses/{project_id}/{house_id}/',\n    examplePath: 'houses/abc123/house_001/',\n  },\n  'user-avatars': {\n    name: 'user-avatars',\n    public: true, // Avatars can be public\n    allowedMimeTypes: ['image/jpeg', 'image/png', 'image/webp'],\n    fileSizeLimit: 2 * 1024 * 1024, // 2MB for avatars\n    description: 'User profile pictures and avatars',\n    folderStructure: 'users/{user_id}/',\n    examplePath: 'users/user789/',\n  },\n  'reports': {\n    name: 'reports',\n    public: false,\n    allowedMimeTypes: [\n      'application/pdf',\n      'application/vnd.ms-excel',\n      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n      'text/csv',\n    ],\n    fileSizeLimit: 25 * 1024 * 1024, // 25MB for reports\n    description: 'Generated reports and analytics files',\n    folderStructure: 'reports/{report_type}/{date}/',\n    examplePath: 'reports/financial/2024-01-15/',\n  },\n} as const\n\n/**\n * RLS Policies SQL for each bucket\n */\nexport const RLS_POLICIES = {\n  'project-photos': `\n    -- Enable RLS on storage.objects\n    ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;\n\n    -- Policy for project photos: Users can access photos from projects they are assigned to\n    CREATE POLICY \"project_photos_select_policy\" ON storage.objects\n    FOR SELECT USING (\n      bucket_id = 'project-photos' AND\n      (\n        -- Allow if user is project manager\n        (SELECT pm_user_id FROM projects WHERE id = (storage.foldername(name))[2]) = auth.uid()::text OR\n        -- Allow if user is assigned to project crew\n        EXISTS (\n          SELECT 1 FROM crew_members cm\n          JOIN crews c ON cm.crew_id = c.id\n          WHERE c.project_id = (storage.foldername(name))[2]::uuid\n          AND cm.user_id = auth.uid()\n        ) OR\n        -- Allow admins\n        (SELECT role FROM users WHERE id = auth.uid()) = 'admin'\n      )\n    );\n\n    CREATE POLICY \"project_photos_insert_policy\" ON storage.objects\n    FOR INSERT WITH CHECK (\n      bucket_id = 'project-photos' AND\n      (\n        -- Same permissions as select\n        (SELECT pm_user_id FROM projects WHERE id = (storage.foldername(name))[2]) = auth.uid()::text OR\n        EXISTS (\n          SELECT 1 FROM crew_members cm\n          JOIN crews c ON cm.crew_id = c.id\n          WHERE c.project_id = (storage.foldername(name))[2]::uuid\n          AND cm.user_id = auth.uid()\n        ) OR\n        (SELECT role FROM users WHERE id = auth.uid()) = 'admin'\n      )\n    );\n\n    CREATE POLICY \"project_photos_update_policy\" ON storage.objects\n    FOR UPDATE USING (\n      bucket_id = 'project-photos' AND\n      (\n        (SELECT pm_user_id FROM projects WHERE id = (storage.foldername(name))[2]) = auth.uid()::text OR\n        (SELECT role FROM users WHERE id = auth.uid()) IN ('admin', 'pm')\n      )\n    );\n\n    CREATE POLICY \"project_photos_delete_policy\" ON storage.objects\n    FOR DELETE USING (\n      bucket_id = 'project-photos' AND\n      (\n        (SELECT pm_user_id FROM projects WHERE id = (storage.foldername(name))[2]) = auth.uid()::text OR\n        (SELECT role FROM users WHERE id = auth.uid()) IN ('admin', 'pm')\n      )\n    );\n  `,\n\n  'work-photos': `\n    -- Policy for work photos: Users can access photos from work entries they created or are assigned to\n    CREATE POLICY \"work_photos_select_policy\" ON storage.objects\n    FOR SELECT USING (\n      bucket_id = 'work-photos' AND\n      (\n        -- Allow if user created the work entry\n        (SELECT user_id FROM work_entries WHERE id = (storage.foldername(name))[2]) = auth.uid() OR\n        -- Allow if user is project manager or foreman\n        (SELECT role FROM users WHERE id = auth.uid()) IN ('admin', 'pm', 'foreman') OR\n        -- Allow if user is in the same project\n        EXISTS (\n          SELECT 1 FROM work_entries we\n          JOIN crew_members cm ON we.crew_id = cm.crew_id\n          WHERE we.id = (storage.foldername(name))[2]::uuid\n          AND cm.user_id = auth.uid()\n        )\n      )\n    );\n\n    CREATE POLICY \"work_photos_insert_policy\" ON storage.objects\n    FOR INSERT WITH CHECK (\n      bucket_id = 'work-photos' AND\n      (\n        -- Allow if user created the work entry\n        (SELECT user_id FROM work_entries WHERE id = (storage.foldername(name))[2]) = auth.uid() OR\n        (SELECT role FROM users WHERE id = auth.uid()) IN ('admin', 'pm', 'foreman', 'crew')\n      )\n    );\n  `,\n\n  'user-avatars': `\n    -- Policy for user avatars: Users can only access their own avatars\n    CREATE POLICY \"user_avatars_select_policy\" ON storage.objects\n    FOR SELECT USING (\n      bucket_id = 'user-avatars' AND\n      (\n        -- Allow users to access their own avatars\n        (storage.foldername(name))[1] = auth.uid()::text OR\n        -- Allow admins to access all avatars\n        (SELECT role FROM users WHERE id = auth.uid()) = 'admin'\n      )\n    );\n\n    CREATE POLICY \"user_avatars_insert_policy\" ON storage.objects\n    FOR INSERT WITH CHECK (\n      bucket_id = 'user-avatars' AND\n      (storage.foldername(name))[1] = auth.uid()::text\n    );\n\n    CREATE POLICY \"user_avatars_update_policy\" ON storage.objects\n    FOR UPDATE USING (\n      bucket_id = 'user-avatars' AND\n      (storage.foldername(name))[1] = auth.uid()::text\n    );\n\n    CREATE POLICY \"user_avatars_delete_policy\" ON storage.objects\n    FOR DELETE USING (\n      bucket_id = 'user-avatars' AND\n      (storage.foldername(name))[1] = auth.uid()::text\n    );\n  `,\n\n  'reports': `\n    -- Policy for reports: Only admins and PMs can access reports\n    CREATE POLICY \"reports_select_policy\" ON storage.objects\n    FOR SELECT USING (\n      bucket_id = 'reports' AND\n      (SELECT role FROM users WHERE id = auth.uid()) IN ('admin', 'pm')\n    );\n\n    CREATE POLICY \"reports_insert_policy\" ON storage.objects\n    FOR INSERT WITH CHECK (\n      bucket_id = 'reports' AND\n      (SELECT role FROM users WHERE id = auth.uid()) IN ('admin', 'pm')\n    );\n\n    CREATE POLICY \"reports_update_policy\" ON storage.objects\n    FOR UPDATE USING (\n      bucket_id = 'reports' AND\n      (SELECT role FROM users WHERE id = auth.uid()) IN ('admin', 'pm')\n    );\n\n    CREATE POLICY \"reports_delete_policy\" ON storage.objects\n    FOR DELETE USING (\n      bucket_id = 'reports' AND\n      (SELECT role FROM users WHERE id = auth.uid()) = 'admin'\n    );\n  `,\n}\n\n/**\n * Create a storage bucket with configuration\n */\nexport async function createBucket(\n  bucketName: StorageBucket,\n  config?: {\n    public?: boolean\n    fileSizeLimit?: number\n    allowedMimeTypes?: string[]\n  }\n) {\n  try {\n    const bucketConfig = BUCKET_CONFIGS[bucketName]\n\n    const { data, error } = await supabase.storage.createBucket(bucketName, {\n      public: config?.public ?? bucketConfig.public,\n      fileSizeLimit: config?.fileSizeLimit ?? bucketConfig.fileSizeLimit,\n      allowedMimeTypes: config?.allowedMimeTypes ?? bucketConfig.allowedMimeTypes,\n    })\n\n    if (error) {\n      // Bucket might already exist\n      if (error.message.includes('already exists')) {\n        console.log(`Bucket ${bucketName} already exists`)\n        return { success: true, message: 'Bucket already exists' }\n      }\n      return { success: false, error: error.message }\n    }\n\n    return { success: true, data, message: `Bucket ${bucketName} created successfully` }\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    }\n  }\n}\n\n/**\n * List all buckets\n */\nexport async function listBuckets() {\n  try {\n    const { data, error } = await supabase.storage.listBuckets()\n\n    if (error) {\n      return { success: false, error: error.message }\n    }\n\n    return { success: true, buckets: data }\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    }\n  }\n}\n\n/**\n * Get bucket configuration\n */\nexport function getBucketConfig(bucketName: StorageBucket) {\n  return BUCKET_CONFIGS[bucketName]\n}\n\n/**\n * Validate file against bucket configuration\n */\nexport function validateFileForBucket(file: File, bucketName: StorageBucket) {\n  const config = BUCKET_CONFIGS[bucketName]\n  const errors: string[] = []\n\n  // Check file size\n  if (file.size > config.fileSizeLimit) {\n    errors.push(`File size exceeds ${config.fileSizeLimit / (1024 * 1024)}MB limit for ${bucketName}`)\n  }\n\n  // Check MIME type\n  if (!config.allowedMimeTypes.includes(file.type)) {\n    errors.push(`File type ${file.type} is not allowed for ${bucketName}`)\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    config,\n  }\n}\n\n/**\n * Generate folder path for a bucket\n */\nexport function generateFolderPath(\n  bucketName: StorageBucket,\n  context: {\n    projectId?: string\n    userId?: string\n    workEntryId?: string\n    houseId?: string\n    reportType?: string\n    category?: string\n    date?: string\n  }\n): string {\n  const config = BUCKET_CONFIGS[bucketName]\n  let path = config.folderStructure\n\n  // Replace placeholders with actual values\n  if (context.projectId) {\n    path = path.replace('{project_id}', context.projectId)\n  }\n  if (context.userId) {\n    path = path.replace('{user_id}', context.userId)\n  }\n  if (context.workEntryId) {\n    path = path.replace('{work_entry_id}', context.workEntryId)\n  }\n  if (context.houseId) {\n    path = path.replace('{house_id}', context.houseId)\n  }\n  if (context.reportType) {\n    path = path.replace('{report_type}', context.reportType)\n  }\n  if (context.category) {\n    path = path.replace('{category}', context.category)\n  }\n  if (context.date) {\n    path = path.replace('{date}', context.date)\n  } else {\n    // Default to current date\n    const currentDate = new Date().toISOString().split('T')[0]\n    path = path.replace('{date}', currentDate)\n    path = path.replace('{timestamp}', new Date().toISOString())\n  }\n\n  return path\n}","import { NextRequest, NextResponse } from 'next/server'\nimport { supabase } from '@/lib/supabase'\nimport { validateFileForBucket, generateFolderPath, BUCKET_CONFIGS } from '@/lib/supabase-buckets'\nimport { generateSecureFileName } from '@/lib/supabase'\nimport type { StorageBucket } from '@/types/upload'\nimport { z } from 'zod'\n\n// Validation schema for upload metadata\nconst uploadMetadataSchema = z.object({\n  bucketName: z.enum(['project-photos', 'work-photos', 'project-documents', 'house-documents', 'user-avatars', 'reports']),\n  projectId: z.string().uuid().optional(),\n  userId: z.string().uuid().optional(),\n  workEntryId: z.string().uuid().optional(),\n  houseId: z.string().uuid().optional(),\n  reportType: z.string().optional(),\n  category: z.string().optional(),\n  metadata: z.record(z.any()).optional(),\n})\n\ninterface FileUploadResult {\n  id: string\n  fileName: string\n  originalName: string\n  size: number\n  type: string\n  url: string\n  path: string\n  bucketName: string\n  uploadedAt: string\n  metadata?: Record<string, any>\n}\n\n/**\n * POST /api/upload\n * Upload files to Supabase Storage with validation and organization\n */\nexport async function POST(request: NextRequest) {\n  try {\n    console.log('ðŸ”¥ Upload API called')\n\n    // Parse multipart form data\n    const formData = await request.formData()\n    console.log('ðŸ“‹ FormData keys:', Array.from(formData.keys()))\n\n    // Get metadata from form data\n    const metadataJson = formData.get('metadata') as string\n    console.log('ðŸ“¦ Metadata JSON:', metadataJson)\n\n    if (!metadataJson) {\n      console.log('âŒ Missing metadata')\n      return NextResponse.json(\n        { error: 'Missing upload metadata' },\n        { status: 400 }\n      )\n    }\n\n    let uploadMetadata\n    try {\n      const parsedMetadata = JSON.parse(metadataJson)\n      console.log('ðŸ” Parsed metadata:', parsedMetadata)\n      uploadMetadata = uploadMetadataSchema.parse(parsedMetadata)\n      console.log('âœ… Metadata validation passed:', uploadMetadata)\n    } catch (error) {\n      console.log('âŒ Metadata validation failed:', error)\n      return NextResponse.json(\n        { error: 'Invalid upload metadata', details: error },\n        { status: 400 }\n      )\n    }\n\n    // Get files from form data\n    const files: File[] = []\n    for (const [key, value] of formData.entries()) {\n      if (key.startsWith('file') && value instanceof File) {\n        files.push(value)\n      }\n    }\n\n    if (files.length === 0) {\n      return NextResponse.json(\n        { error: 'No files provided' },\n        { status: 400 }\n      )\n    }\n\n    const bucketName = uploadMetadata.bucketName as StorageBucket\n    const bucketConfig = BUCKET_CONFIGS[bucketName]\n\n    // Check maximum files per batch\n    if (files.length > 5) {\n      return NextResponse.json(\n        { error: 'Maximum 5 files per upload batch' },\n        { status: 400 }\n      )\n    }\n\n    // Validate all files before uploading\n    const validationErrors: string[] = []\n    for (const file of files) {\n      const validation = validateFileForBucket(file, bucketName)\n      if (!validation.isValid) {\n        validationErrors.push(`${file.name}: ${validation.errors.join(', ')}`)\n      }\n    }\n\n    if (validationErrors.length > 0) {\n      return NextResponse.json(\n        { error: 'File validation failed', details: validationErrors },\n        { status: 400 }\n      )\n    }\n\n    // Generate folder path\n    const folderPath = generateFolderPath(bucketName, {\n      projectId: uploadMetadata.projectId,\n      userId: uploadMetadata.userId,\n      workEntryId: uploadMetadata.workEntryId,\n      houseId: uploadMetadata.houseId,\n      reportType: uploadMetadata.reportType,\n      category: uploadMetadata.category,\n    })\n\n    // Upload files\n    const uploadResults: FileUploadResult[] = []\n    const uploadErrors: Array<{ fileName: string; error: string }> = []\n\n    for (const file of files) {\n      try {\n        // Generate secure file name\n        const secureFileName = generateSecureFileName(file.name, uploadMetadata.userId)\n        const filePath = `${folderPath}${secureFileName}`\n\n        // Upload to Supabase Storage\n        const { data, error } = await supabase.storage\n          .from(bucketName)\n          .upload(filePath, file, {\n            contentType: file.type,\n            cacheControl: '3600',\n            upsert: false,\n          })\n\n        if (error) {\n          uploadErrors.push({\n            fileName: file.name,\n            error: error.message,\n          })\n          continue\n        }\n\n        // Get public URL for the uploaded file\n        const { data: urlData } = supabase.storage\n          .from(bucketName)\n          .getPublicUrl(data.path)\n\n        // Create upload result\n        const uploadResult: FileUploadResult = {\n          id: crypto.randomUUID(),\n          fileName: secureFileName,\n          originalName: file.name,\n          size: file.size,\n          type: file.type,\n          url: urlData.publicUrl,\n          path: data.path,\n          bucketName,\n          uploadedAt: new Date().toISOString(),\n          metadata: uploadMetadata.metadata,\n        }\n\n        uploadResults.push(uploadResult)\n\n        console.log(`âœ… File uploaded successfully: ${file.name} -> ${data.path}`)\n      } catch (error) {\n        console.error(`âŒ Error uploading file ${file.name}:`, error)\n        uploadErrors.push({\n          fileName: file.name,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        })\n      }\n    }\n\n    // Return results\n    const response = {\n      success: uploadResults.length > 0,\n      message: `${uploadResults.length} file(s) uploaded successfully`,\n      files: uploadResults,\n      errors: uploadErrors,\n      totalFiles: files.length,\n      successCount: uploadResults.length,\n      errorCount: uploadErrors.length,\n    }\n\n    const statusCode = uploadResults.length === files.length ? 200 : 207 // 207 Multi-Status for partial success\n\n    return NextResponse.json(response, { status: statusCode })\n  } catch (error) {\n    console.error('File upload API error:', error)\n    return NextResponse.json(\n      {\n        error: 'Internal server error during file upload',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * GET /api/upload?bucketName=<bucket>&path=<path>\n * Get file information or list files in a bucket\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const bucketName = searchParams.get('bucketName') as StorageBucket\n    const path = searchParams.get('path') || ''\n    const limit = parseInt(searchParams.get('limit') || '50')\n\n    if (!bucketName || !BUCKET_CONFIGS[bucketName]) {\n      return NextResponse.json(\n        { error: 'Invalid bucket name' },\n        { status: 400 }\n      )\n    }\n\n    // List files in the specified bucket and path\n    const { data, error } = await supabase.storage\n      .from(bucketName)\n      .list(path, {\n        limit,\n        sortBy: { column: 'created_at', order: 'desc' },\n      })\n\n    if (error) {\n      return NextResponse.json(\n        { error: 'Failed to list files', details: error.message },\n        { status: 500 }\n      )\n    }\n\n    // Transform file data\n    const files = data?.map(file => ({\n      id: file.id,\n      name: file.name,\n      size: file.metadata?.size || 0,\n      type: file.metadata?.mimetype || 'unknown',\n      lastModified: file.updated_at || file.created_at,\n      path: `${path}${file.name}`,\n      isFolder: file.id === null, // Folders have null id\n    })) || []\n\n    return NextResponse.json({\n      bucketName,\n      path,\n      files,\n      total: files.length,\n    })\n  } catch (error) {\n    console.error('File listing API error:', error)\n    return NextResponse.json(\n      {\n        error: 'Internal server error during file listing',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * DELETE /api/upload?bucketName=<bucket>&path=<path>\n * Delete a file from Supabase Storage\n */\nexport async function DELETE(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const bucketName = searchParams.get('bucketName') as StorageBucket\n    const path = searchParams.get('path')\n\n    if (!bucketName || !BUCKET_CONFIGS[bucketName]) {\n      return NextResponse.json(\n        { error: 'Invalid bucket name' },\n        { status: 400 }\n      )\n    }\n\n    if (!path) {\n      return NextResponse.json(\n        { error: 'File path is required' },\n        { status: 400 }\n      )\n    }\n\n    // Delete the file\n    const { error } = await supabase.storage\n      .from(bucketName)\n      .remove([path])\n\n    if (error) {\n      return NextResponse.json(\n        { error: 'Failed to delete file', details: error.message },\n        { status: 500 }\n      )\n    }\n\n    return NextResponse.json({\n      success: true,\n      message: `File deleted successfully: ${path}`,\n      bucketName,\n      path,\n    })\n  } catch (error) {\n    console.error('File deletion API error:', error)\n    return NextResponse.json(\n      {\n        error: 'Internal server error during file deletion',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    )\n  }\n}","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/upload/route\",\n        pathname: \"/api/upload\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/upload/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/upload/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!getRequestMeta(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!getRequestMeta(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(getRequestMeta(req, 'minimalMode') && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n"],"names":[],"mappings":"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","ignoreList":[3]}