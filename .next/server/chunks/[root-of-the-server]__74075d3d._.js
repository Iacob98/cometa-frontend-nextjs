module.exports = [
"[project]/.next-internal/server/app/api/project-preparation/plans/route/actions.js [app-rsc] (server actions loader, ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[project]/src/lib/supabase.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FILE_UPLOAD_CONFIG",
    ()=>FILE_UPLOAD_CONFIG,
    "STORAGE_BUCKETS",
    ()=>STORAGE_BUCKETS,
    "generateSecureFileName",
    ()=>generateSecureFileName,
    "getFileCategoryFromBucket",
    ()=>getFileCategoryFromBucket,
    "supabase",
    ()=>supabase,
    "validateFile",
    ()=>validateFile
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
;
// Supabase configuration
const supabaseUrl = ("TURBOPACK compile-time value", "https://oijmohlhdxoawzvctnxx.supabase.co");
const supabaseAnonKey = ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9pam1vaGxoZHhvYXd6dmN0bnh4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyODUzMjcsImV4cCI6MjA3MDg2MTMyN30.vw9G5hcSfd-m5AZqeGlmzGvqc9ImYioDFR-AsiHoFro");
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(supabaseUrl, supabaseAnonKey, {
    auth: {
        persistSession: true,
        autoRefreshToken: true
    }
});
const STORAGE_BUCKETS = {
    PROJECT_PHOTOS: process.env.SUPABASE_PROJECT_PHOTOS_BUCKET || 'project-photos',
    WORK_PHOTOS: process.env.SUPABASE_WORK_PHOTOS_BUCKET || 'work-photos',
    PROJECT_DOCUMENTS: process.env.SUPABASE_PROJECT_DOCUMENTS_BUCKET || 'project-documents',
    HOUSE_DOCUMENTS: process.env.SUPABASE_HOUSE_DOCUMENTS_BUCKET || 'house-documents',
    USER_AVATARS: process.env.SUPABASE_USER_AVATARS_BUCKET || 'user-avatars',
    REPORTS: process.env.SUPABASE_REPORTS_BUCKET || 'reports'
};
const FILE_UPLOAD_CONFIG = {
    // Maximum file size: 10MB
    MAX_FILE_SIZE: 10 * 1024 * 1024,
    // Maximum files per batch upload
    MAX_FILES_PER_BATCH: 5,
    // Allowed file types
    ALLOWED_FILE_TYPES: {
        IMAGES: [
            'image/jpeg',
            'image/png',
            'image/gif',
            'image/webp'
        ],
        DOCUMENTS: [
            'application/pdf',
            'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        ],
        SPREADSHEETS: [
            'application/vnd.ms-excel',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        ],
        PLANS: [
            'application/pdf',
            'application/dwg',
            'application/dxf',
            'image/jpeg',
            'image/png',
            'image/gif',
            'image/webp',
            'image/bmp',
            'image/tiff'
        ]
    },
    // Get all allowed MIME types
    getAllowedTypes: ()=>{
        const allTypes = [
            ...FILE_UPLOAD_CONFIG.ALLOWED_FILE_TYPES.IMAGES,
            ...FILE_UPLOAD_CONFIG.ALLOWED_FILE_TYPES.DOCUMENTS,
            ...FILE_UPLOAD_CONFIG.ALLOWED_FILE_TYPES.SPREADSHEETS,
            ...FILE_UPLOAD_CONFIG.ALLOWED_FILE_TYPES.PLANS
        ];
        // Remove duplicates using Set
        return [
            ...new Set(allTypes)
        ];
    }
};
const validateFile = (file)=>{
    const errors = [];
    // Check file size
    if (file.size > FILE_UPLOAD_CONFIG.MAX_FILE_SIZE) {
        errors.push(`File size must be less than ${FILE_UPLOAD_CONFIG.MAX_FILE_SIZE / (1024 * 1024)}MB`);
    }
    // Check file type
    const allowedTypes = FILE_UPLOAD_CONFIG.getAllowedTypes();
    console.log('ðŸ” File validation:', {
        fileName: file.name,
        fileType: file.type,
        allowedTypes,
        isTypeAllowed: allowedTypes.includes(file.type)
    });
    if (!allowedTypes.includes(file.type)) {
        errors.push(`File type ${file.type} is not allowed`);
    }
    return {
        isValid: errors.length === 0,
        errors
    };
};
const generateSecureFileName = (originalFileName, userId)=>{
    const timestamp = Date.now();
    const randomString = Math.random().toString(36).substring(2, 15);
    const fileExtension = originalFileName.split('.').pop();
    const baseName = originalFileName.split('.')[0].toLowerCase().replace(/[^a-z0-9]/g, '-');
    const prefix = userId ? `${userId}_` : '';
    return `${prefix}${baseName}_${timestamp}_${randomString}.${fileExtension}`;
};
const getFileCategoryFromBucket = (bucketName)=>{
    const bucketMap = {
        [STORAGE_BUCKETS.PROJECT_PHOTOS]: 'project-photo',
        [STORAGE_BUCKETS.WORK_PHOTOS]: 'work-photo',
        [STORAGE_BUCKETS.PROJECT_DOCUMENTS]: 'project-document',
        [STORAGE_BUCKETS.HOUSE_DOCUMENTS]: 'house-document',
        [STORAGE_BUCKETS.USER_AVATARS]: 'user-avatar',
        [STORAGE_BUCKETS.REPORTS]: 'report'
    };
    return bucketMap[bucketName] || 'unknown';
};
}),
"[project]/src/lib/upload-utils.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createPresignedUploadUrl",
    ()=>createPresignedUploadUrl,
    "deleteFile",
    ()=>deleteFile,
    "getFileInfo",
    ()=>getFileInfo,
    "getSignedUrl",
    ()=>getSignedUrl,
    "listFiles",
    ()=>listFiles,
    "saveFileMetadata",
    ()=>saveFileMetadata,
    "uploadFile",
    ()=>uploadFile,
    "uploadMultipleFiles",
    ()=>uploadMultipleFiles,
    "uploadToSignedUrl",
    ()=>uploadToSignedUrl,
    "validateFiles",
    ()=>validateFiles
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/supabase.ts [app-route] (ecmascript)");
;
async function uploadFile(file, options, supabaseClient) {
    // Use provided client or fallback to default
    const { supabase } = await __turbopack_context__.A("[project]/src/lib/supabase.ts [app-route] (ecmascript, async loader)");
    const client = supabaseClient || supabase;
    try {
        // Validate file
        const validation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateFile"])(file);
        if (!validation.isValid) {
            return {
                success: false,
                error: validation.errors.join(', ')
            };
        }
        // Generate secure filename
        const fileName = options.fileName || (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateSecureFileName"])(file.name);
        const filePath = options.folder ? `${options.folder}/${fileName}` : fileName;
        // Upload to Supabase Storage
        const { data, error } = await client.storage.from(options.bucketName).upload(filePath, file, {
            cacheControl: options.cacheControl || '3600',
            contentType: options.contentType || file.type,
            upsert: options.upsert || false,
            metadata: options.metadata
        });
        if (error) {
            return {
                success: false,
                error: error.message
            };
        }
        // Get public URL
        const { data: urlData } = client.storage.from(options.bucketName).getPublicUrl(data.path);
        return {
            success: true,
            url: urlData.publicUrl,
            path: data.path
        };
    } catch (error) {
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function uploadMultipleFiles(files, options) {
    const results = {
        successful: [],
        failed: [],
        totalFiles: files.length,
        successCount: 0,
        failureCount: 0
    };
    // Process files concurrently (limit to avoid rate limiting)
    const CONCURRENT_UPLOADS = 3;
    const batches = [];
    for(let i = 0; i < files.length; i += CONCURRENT_UPLOADS){
        batches.push(files.slice(i, i + CONCURRENT_UPLOADS));
    }
    for (const batch of batches){
        const promises = batch.map(async (file)=>{
            const result = await uploadFile(file, options);
            if (result.success) {
                const uploadedFile = {
                    id: crypto.randomUUID(),
                    name: file.name,
                    originalName: file.name,
                    size: file.size,
                    type: file.type,
                    url: result.url,
                    path: result.path,
                    bucketName: options.bucketName,
                    uploadedAt: new Date().toISOString(),
                    metadata: options.metadata
                };
                results.successful.push(uploadedFile);
                results.successCount++;
            } else {
                results.failed.push({
                    file,
                    error: {
                        code: 'UPLOAD_FAILED',
                        message: result.error || 'Upload failed'
                    }
                });
                results.failureCount++;
            }
        });
        await Promise.all(promises);
    }
    return results;
}
async function deleteFile(bucketName, filePath) {
    try {
        const { supabase } = await __turbopack_context__.A("[project]/src/lib/supabase.ts [app-route] (ecmascript, async loader)");
        const { error } = await supabase.storage.from(bucketName).remove([
            filePath
        ]);
        if (error) {
            return {
                success: false,
                error: error.message
            };
        }
        return {
            success: true
        };
    } catch (error) {
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function getSignedUrl(bucketName, filePath, expiresIn = 3600) {
    try {
        const { supabase } = await __turbopack_context__.A("[project]/src/lib/supabase.ts [app-route] (ecmascript, async loader)");
        const { data, error } = await supabase.storage.from(bucketName).createSignedUrl(filePath, expiresIn);
        if (error) {
            return {
                error: error.message
            };
        }
        return {
            url: data.signedUrl
        };
    } catch (error) {
        return {
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function listFiles(bucketName, folder, limit = 100, offset = 0) {
    try {
        const { supabase } = await __turbopack_context__.A("[project]/src/lib/supabase.ts [app-route] (ecmascript, async loader)");
        const { data, error } = await supabase.storage.from(bucketName).list(folder, {
            limit,
            offset
        });
        if (error) {
            return {
                files: [],
                error: error.message
            };
        }
        return {
            files: data || [],
            error: null
        };
    } catch (error) {
        return {
            files: [],
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function getFileInfo(bucketName, filePath) {
    try {
        const { supabase } = await __turbopack_context__.A("[project]/src/lib/supabase.ts [app-route] (ecmascript, async loader)");
        const { data, error } = await supabase.storage.from(bucketName).list(filePath.split('/').slice(0, -1).join('/') || undefined, {
            search: filePath.split('/').pop()
        });
        if (error) {
            return {
                info: null,
                error: error.message
            };
        }
        const fileInfo = data?.find((item)=>item.name === filePath.split('/').pop());
        return {
            info: fileInfo || null,
            error: null
        };
    } catch (error) {
        return {
            info: null,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function createPresignedUploadUrl(bucketName, filePath) {
    try {
        const { supabase } = await __turbopack_context__.A("[project]/src/lib/supabase.ts [app-route] (ecmascript, async loader)");
        const { data, error } = await supabase.storage.from(bucketName).createSignedUploadUrl(filePath);
        if (error) {
            return {
                error: error.message
            };
        }
        return {
            token: data.token
        };
    } catch (error) {
        return {
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function uploadToSignedUrl(bucketName, filePath, token, file) {
    try {
        const { supabase } = await __turbopack_context__.A("[project]/src/lib/supabase.ts [app-route] (ecmascript, async loader)");
        const { data, error } = await supabase.storage.from(bucketName).uploadToSignedUrl(filePath, token, file);
        if (error) {
            return {
                success: false,
                error: error.message
            };
        }
        // Get public URL
        const { data: urlData } = supabase.storage.from(bucketName).getPublicUrl(data.path);
        return {
            success: true,
            url: urlData.publicUrl,
            path: data.path
        };
    } catch (error) {
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function saveFileMetadata(metadata) {
    // This would typically save to your PostgreSQL database
    // You'll need to create a files table and implement this function
    console.log('Saving file metadata:', metadata);
    // Placeholder implementation - replace with actual database call
    return {
        success: true,
        id: crypto.randomUUID()
    };
}
function validateFiles(files) {
    const errors = [];
    if (files.length === 0) {
        errors.push('No files selected');
        return {
            isValid: false,
            errors
        };
    }
    // Check batch size limit
    if (files.length > 5) {
        errors.push('Maximum 5 files allowed per batch');
    }
    // Validate each file
    files.forEach((file, index)=>{
        const validation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateFile"])(file);
        if (!validation.isValid) {
            errors.push(`File ${index + 1} (${file.name}): ${validation.errors.join(', ')}`);
        }
    });
    return {
        isValid: errors.length === 0,
        errors
    };
}
}),
"[project]/src/app/api/project-preparation/plans/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET,
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$upload$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/upload-utils.ts [app-route] (ecmascript)");
;
;
;
// Service role client for bypassing RLS
const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(("TURBOPACK compile-time value", "https://oijmohlhdxoawzvctnxx.supabase.co"), process.env.SUPABASE_SERVICE_ROLE_KEY || ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9pam1vaGxoZHhvYXd6dmN0bnh4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyODUzMjcsImV4cCI6MjA3MDg2MTMyN30.vw9G5hcSfd-m5AZqeGlmzGvqc9ImYioDFR-AsiHoFro"));
async function GET(request) {
    try {
        const { searchParams } = new URL(request.url);
        const project_id = searchParams.get("project_id");
        if (!project_id) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Project ID is required"
            }, {
                status: 400
            });
        }
        // Get project plans from database
        const { data: plans, error } = await supabase.from('project_plans').select(`
        id,
        title,
        description,
        plan_type,
        filename,
        file_size,
        file_url,
        file_path,
        uploaded_at
      `).eq('project_id', project_id).order('uploaded_at', {
            ascending: false
        });
        if (error) {
            console.error('Supabase project plans query error:', error);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Failed to fetch project plans'
            }, {
                status: 500
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(plans || []);
    } catch (error) {
        console.error("Plans API error:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "Failed to fetch plans"
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    try {
        // Handle both JSON and FormData requests
        const contentType = request.headers.get('content-type') || '';
        let project_id, title, description, plan_type, filename, file_size, file_url, file_path;
        if (contentType.includes('multipart/form-data')) {
            // Handle FormData with file upload
            const formData = await request.formData();
            project_id = formData.get('project_id');
            title = formData.get('title');
            description = formData.get('description');
            plan_type = formData.get('plan_type');
            const file = formData.get('file');
            if (!project_id || !title || !plan_type || !file) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: "Project ID, title, plan type, and file are required"
                }, {
                    status: 400
                });
            }
            // Upload file to Supabase Storage
            console.log('Uploading file to Supabase Storage:', {
                fileName: file.name,
                fileSize: file.size,
                fileType: file.type,
                projectId: project_id,
                planType: plan_type
            });
            // Generate folder path for project documents
            const folderPath = `projects/${project_id}/plans`;
            const uploadResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$upload$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["uploadFile"])(file, {
                bucketName: 'project-documents',
                folder: folderPath,
                metadata: {
                    project_id,
                    plan_type,
                    title,
                    description: description || '',
                    uploaded_by: 'system',
                    upload_source: 'project_preparation'
                }
            }, supabase); // Pass the service role client
            if (!uploadResult.success) {
                console.error('File upload failed:', uploadResult.error);
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: `File upload failed: ${uploadResult.error}`
                }, {
                    status: 500
                });
            }
            console.log('File uploaded successfully:', uploadResult);
            // Set file info from upload result
            filename = file.name;
            file_size = file.size;
            file_url = uploadResult.url;
            file_path = uploadResult.path;
        } else {
            // Handle JSON requests
            const body = await request.json();
            ({ project_id, title, description, plan_type, filename, file_size, file_url, file_path } = body);
            if (!project_id || !title || !plan_type || !filename) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: "Project ID, title, plan type, and filename are required"
                }, {
                    status: 400
                });
            }
        }
        // Create project plan in database
        const { data: plan, error } = await supabase.from('project_plans').insert({
            project_id,
            title,
            description,
            plan_type,
            filename,
            file_size: file_size || 0,
            file_url: file_url || '',
            file_path: file_path || ''
        }).select().single();
        if (error) {
            console.error('Supabase project plan creation error:', error);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Failed to create project plan'
            }, {
                status: 500
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            plan_id: plan.id,
            message: "Project plan created successfully",
            plan
        }, {
            status: 201
        });
    } catch (error) {
        console.error("Plans POST error:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "Failed to create plan"
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__74075d3d._.js.map